import os

dataFile = "/lab/work/porchard/SRR891268_allelic_bias/work/counts/GM12878.post_mpileup.out"
expectedFracRefFile = "/lab/work/porchard/SRR891268_allelic_bias/work/counts/GM12878.post_mpileup.err"
# Info from Peter : olumns are "chromosome", "start", "end", "allele_1", "allele_2", "ref", "total_coverage", "ref_coverage", "fraction_ref", "p.value", "significant", "neg_log_10_p.value", "SNP_pair".
## the file includes all SNPs with minimum coverage = 10.
## for the islet analysis, we filtered to minimum coverage = 20, and at least 2 counts observed for alt and for ref, and then did the p-value adjustment

rule final:
    input:
        os.path.join(DIRECTORIES['figures'], "fig.deviationFromExpectation.pdf")


headerList = ["chrom", "start", "end", "allele_1", "allele_2", "ref", "total_coverage", "ref_coverage", "fraction_ref", "p.value", "significant", "neg_log_10_p.value", "SNP_pair"]
headerString_getExpectedFracRef = ' '.join(headerList)
# headerString_getExpectedFracRef = """ "%s" """ %(headerString_getExpectedFracRef)

rule getExpectedFracRef:
    input:
        fracRef = rules.linkFracRefFile.output,
        datfile = rules.linkDataFile.output
    output:
        os.path.join(DIRECTORIES['intermediateFiles'], "GM12878.allelicBiasResults.FracRef.dat")
    shell:
        """python ~arushiv/toolScripts/merge2FilesByColnames.py {input.datfile} {input.fracRef} {output} -h1 {headerString_getExpectedFracRef} -h2 SNP_pair expectedFracRef -t inner -on SNP_pair  """


# Test to perform 3 kinds of coverage filtering and get qvalues corresponding to each filter
rule performFilteringAndGetQvalues:
    input:
        rules.getExpectedFracRef.output
    output:
        os.path.join(DIRECTORIES['intermediateFiles'], "GM12878.allelicBiasResults.FracRef.filterQvalues.coverageFilterQvals.dat")
    script:
        os.path.join(DIRECTORIES['scripts'], "coverageFilt_qvalue.R")


## This function was already written to be performed by submitting a drmr script. So, create drmr file, submit job, create latency wait in snakemake for it to wait for the output file to be finally generated
## Or, can incorporate drmr file creating script to run jobs from snakefile itself, using defined resources in the config file
rule getMAF:
    input:
        rules.performFilteringAndGetQvalues.output
    output:
        # "getMAF.dr"
        os.path.join(DIRECTORIES['intermediateFiles'], "GM12878.allelicBiasResults.FracRef.filterQvalues.coverageFilterQvals.withMAF.dat")
    run:
        with open(input[0], 'r') as f:
            headerString_getMAF = f.readline().rstrip()
        print(headerString_getMAF)
        shell(r""" python %s {input} {output} --now -od %s  -name getMAF.dr -pop EUR_AF -h1 {headerString_getMAF}""" %(os.path.join(DIRECTORIES['scripts'], "getMAFfrom1000gvcf_new.py"), DIRECTORIES['intermediateFiles']))


# headerString_intersectAnnotations = '\\t'.join(headerList)
# headerString_intersectAnnotations = """ "%s" """ %(headerString_intersectAnnotations)
        
rule intersectAnnotations:
    input:
        rules.getMAF.output
    output:
        os.path.join(DIRECTORIES['intermediateFiles'], "GM12878.allelicBiasResults.FracRef.filterQvalues.coverageFilterQvals.withMAF.annotations.dat")
    run:
        with open(input[0], 'r') as f:
            headerString_intersectAnnotations = f.readline().rstrip() + '\tcell\tannotation'
            print(headerString_intersectAnnotations)
        shell(
            r"""
            for i in `ls {annotationDirectory}*.annotations.bed | grep GM12878 | grep -v common`; do b=`basename $i .annotations.bed | sed -e 's:\.:\t:g'`; grep -v chrom {input} | intersectBed -a - -b $i | awk '{{print $0"\t""'"$b"'"}}' OFS='\t'; done > {output};
            echo {headerString_intersectAnnotations} | cat - {output} > temp;
            mv temp {output};
            """
            )


rule plot:
    input:
        rules.intersectAnnotations.output
    output:
        os.path.join(DIRECTORIES['figures'], "fig.deviationFromExpectation.pdf")
    script:
        os.path.join(DIRECTORIES['scripts'], "plot.R")
